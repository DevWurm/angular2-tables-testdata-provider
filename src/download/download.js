/*
 * Copyright 2016 DevWurm
 * Licensed under MIT (https://github.com/DevWurm/angular2-tables-testdata-provider/blob/master/LICENSE)
 */

import * as path from "path";
import {createWriteStream} from "fs";
import {request as httpRequest} from "http";
import {request as httpsRequest} from "https";
import {parse as parseUrl} from "url";
import {Transform, Writable} from "stream";

/**
 * downloads a row of files, identified by patterns
 * @access public
 *
 * @param sourcePattern {String} url pattern, which contains variables which will be substituded by the rules specified in the rules parameter
 * @param rules {[Object]} array of rule objects. Each rule object needs a variable field and either a from and to property or a values array
 * @param destPattern {String} [Optional] destination file pattern, which is applied like the sourcePattern. If not provided the file contents are provided via the return value
 * @param decompressor {Stream} [Optional] If specified the data will be decompressed using the specified decompressor stream
 *
 * @return {[Promise]} Array of promises of which each either contains the filepath of the result path or the resulting data
 */
export default function download(sourcePattern, rules, destPattern) {
    let paths = [];
    const sources = applyPattern(sourcePattern, rules);
    if (destPattern) {
        const dests = applyPattern(destPattern, rules);
        paths = sources.map((src, key) => {source: src, dest: dests[key]};);
    } else {
        paths = sources.map(src => {source: src});
    }

    return paths.map(identifier => downloadFile(identifier.source, identifier.dest, decompressor));
}

/**
 * applies a set of rules to a pattern, to generate all wanted idetifiers
 * @access private
 * @param pattern {String / [String]} pattern or array of patterns which will be applied
 * @param rules {[Object]} array of rule objects. Each rule object needs a variable field and either a from and to property or a values array ( is split into rule and rules)
 *
 * @return {[String]} Array of result identifiers
 */
function applyPattern(pattern, [rule, ...rules]) {
    const patterns = (pattern instanceof Array) ? pattern : [pattern];

    if (!rule) return patterns;

    return applyPattern(patterns.map(pattern => applyRule(pattern, rule)), rules);
}

/**
 * applies a specific rule to a pattern
 * @access private
 * @param pattern {String} pattern, which will be applied
 * @param rule {Object} rule object, which will be applied. The rule object needs a variable field and either a from and to property or a values array 
 *
 * @return {[String]} The array of identifiers generated by this rule from the pattern
 */
function applyRule(pattern, {variable, from, to, values, padChar}) {
   const regExp = new RegExp(`(${variable}+)`, 'g');

   const vals = (!values) ? new Array(Number(to) - Number(from)).map((val, key) => Number(from) + key) : values;

   return vals.map(val => {
        let result = ""
        
        let chunk = pattern;
        while (const match = regExp.exec(chunk)) {
            result += chunk.substr(0, match.index) + pad(val, match[1].length) + chunk.substr(match.index + match[1].length, (match.lastIndex) ? match.lastIndex : undefined);
            chunk = (match.lastIndex) ? chunk.substr(match.lastIndex) : "";
        }
        
        return result;
   }
}

/**
 * padds a String with preceeding characters, until it has the correct length
 * @access private
 * @param value {String} value, which will be padded
 * @param length {Integer} target length of the value
 * @param padChar {Character (String)} [Optional] character which will be used for padding (default: 0)
 *
 * @return {String} padded value
 */
function pad(value, length, padChar='0') {
        return (value.toString().length < length) ? pad(padChar + value, length):value;
}


/**
 * downloads and uncompresses a file, if it's a compressed file
 * @access public
 * 
 * @param url {String} url of the source file
 * @param target {String} [Optional] If specified the result of the download is stored in the target file, otherwise it's rported via the return value (not recommended)
 * @param decompressor {Stream} [Optional] If specified the data will be decompressed using the specified decompressor stream
 *
 * @return {Promise} Promise which is either resolved with the content of the downlaod file or the filepath
 */
export function downloadFile(url, target, decompressor) {
    return new Promise((resolve, reject) => {
        if (!url) return reject(new Error('Nor target Url specified'));
        
        const request = parseUrl(url).protocol == 'https:' ? httpsRequest : httpRequest;

        // create and send get request to url
        const req = request(url, res => {
            const out = target ? createWriteStream(target) : new StringWriter();
            const dec = decompressor ? decompressor : new PassiveStream();

            res.on('error', reject);
            dec.on('error', reject);
            out.on('error', reject);
            
            res.pipe(dec).pipe(out);

            out.on('finish', () => resolve(target ? target : out.result));
        });

        req.end()

        req.on('error', reject);
    });
}


/**
 * Transform stream which does nothing then piping the content to the next stream
 * @access private
 */
class PassiveStream extends Transform {
    constructor() {
        super();
    }

    _transform(data, encoding, done) {
        this.push(data);
        done();
    };
}

/**
 * Writer which writes the content into the result property
 * @access private
 */
class StringWriter extends Writable {
    constructor() {
        super();
        this.result = "";
    }

    _write(chunk, enc, next) {
        this.result += chunk.toString(enc);
        next();
    };
}
